---
title: "etl_qa_run_pipeline()"
format: 
  gfm:
    prefer-html: false
    embed-resources: false
editor: visual
---

```{r echo=FALSE}
#| warning: false
#| message: false
library(apde)
library(kableExtra)

# function to beautify tables
pretty_kable <- function(dt) { 
  knitr::kable(dt, format = 'markdown')
}
```

# Introduction

The `etl_qa_run_pipeline()` function is designed to identify data quality issues before performing data analysis. To maximize its effectiveness, it is recommended to use this tool throughout the ETL pipeline. It can be run after extraction to ensure that the data we received is as expected and has not been corrupted during transmission. After transformation, it can check for error introduced by coding mistakes. Finally, after loading the data to its near-final destination, it can be run again — perhaps by an analyst familiar with the data — to check for any remaining data quality issues.

In essence, the function draws data from SQL Server, a data.table or data.frame in R's memory, or via the [`rads::get_data_xxx`](https://github.com/PHSKC-APDE/rads/wiki/get_data) functions. It identifies missing data and assesses changes in numeric statistics and categorical frequency distributions over time. Results are provided as tables that can be filtered and reviewed (and easily read into Tableau) and as PDF graphs that help identify changes over time. Optionally, it can check if variables align with CHI (Community Health Indicators) standards.

# Sneak peek at QA output

The function returns a named list containing four items:

-   `config`: Configuration settings used for the analysis
-   `initial`: Initial ETL QA results
-   `final`: Final ETL QA data.table summaries that are exported and used in plots
-   `exported`: File paths for exported tables and plots

Here is a peek at the output generated by the example code that will be discussed in detail below.

## Graphs

### Figure 1: Missingness

This graph shows the percentage of observations (i.e., rows) that are missing at each time period.<br><br> ![](etl_qa_run_pipeline_files/etl_qa_missing.jpg){#fig-missing}

### Figure 2a: Numeric statistics

This graph shows basic statistics for *numeric* variables at each time period.<br><br> ![](etl_qa_run_pipeline_files/etl_qa_continuous.jpg){#fig-continuous}

### Figure 2b: Date statistics

This graph shows basic statistics for *date* variables at each time period. Note that datetime variables such as `POSIXct` and `POSIXt` in R and `datetime`, `datetime2`, and `smalldatetime` in SQL will assessed as dates.<br><br> ![](etl_qa_run_pipeline_files/etl_qa_date.jpg){#fig-date}

### Figure 2c: Categorical frequencies

This graph shows the proportion of observations with a given value at each time period. It displays the top eight most frequent values PLUS missing values (dotted line) PLUS all other values combined and labeled 'Other values'. Note that numeric and date variables with fewer than or equal to your specified `distinct_threshold` unique values will be treated as categorical. This threshold (default = 1) is particularly useful for controlling how ordinal variables or numeric codes with limited values are analyzed.<br><br> ![](etl_qa_run_pipeline_files/etl_qa_categorical.jpg){#fig-categorical}

## Tables

As you can see in the figure from Figure 2c, the proportion lines can overlap and it can be difficult to identify all the differences that might be of interest. For a more detailed exploration of this data, you can view the tables stored in the exported Excel file (which are also saved in the `final` item of the returned list). Here is a snapshot of each of tables:

```{r echo=FALSE, results='hide', warning=FALSE, message=FALSE}
# Perform the calculations, but don't directly display output
myconnection <- rads::validate_hhsaw_key()
qaSQL <- etl_qa_run_pipeline(
  data_source_type = 'sql_server',
  connection = myconnection,
  data_params = list(
    schema_table = 'birth.final_analytic',
    time_var = 'chi_year',
    time_range = c(2013, 2022),
    cols =c('chi_age', 'race4', 'birth_weight_grams', 'birthplace_city', 
            'num_prev_cesarean', 'mother_date_of_birth'), 
    check_chi = TRUE
  ), 
  output_directory = tempdir()
)
```

### missingness

Here is a sample of the 'missingness' worksheet saved to the Excel file. You would be able to access this in R by typing something like `myresult$final$missingness`. As per the default settings (which can be adjusted), it is flagging \>= 3% *absolute* changes in the proportion missing between adjacent time periods.

```{r echo=FALSE, results='show', warning=FALSE, message=FALSE}
# Get a sample of the final missingness table
sample_missing <- qaSQL$final$missingness
keepers <- which(!is.na(sample_missing$abs_change))[1]
keepers <- (keepers - 4):(keepers + 4)
pretty_kable(sample_missing[keepers])

```

### values

Similarly, here is a sample from the 'values' worksheet (`myresult$final$values`). The default settings flag rows with a \>= 2% *relative* change in the mean value between adjacent years.

```{r echo=FALSE, results='show', warning=FALSE, message=FALSE}
# Get a sample of the final values table
sample_values <- qaSQL$final$values
keepers <- which(!is.na(sample_values$rel_mean_change))[1]
keepers <- (keepers - 4):(keepers + 4)
pretty_kable(sample_values[keepers])
```

### chi_standards

Finally, if you set `check_chi = TRUE`, your Excel workbook will have a sheet called 'chi_standards' (`myresult$final$chi_standards`). It provides a simple '\*' to indicate when there is a misalignment between the CHI standard and your data.

```{r echo=FALSE, results='show', warning=FALSE, message=FALSE}
# Get a sample of the final values table
sample_chi <- qaSQL$final$chi_standards
keepers <- which(!is.na(sample_chi$problem))[1]
keepers <- (keepers - 4):(keepers + 4)
pretty_kable(sample_chi[keepers])
```

Now that you've learned what this function can do, let's learn how to use it!

# Setting up the environment

Start by loading the package:

```{r echo=TRUE, results='hide'}
#| warning: false
#| message: false
library(apde)
```

# Function arguments

Since this function allows the user to QA data in three different data sources that need different specifications, understanding the arguments is not as simple as typing `args(etl_qa_run_pipeline)`. Here are all the possible arguments as described in the helpfile (`?etl_qa_run_pipeline`):

## `data_source_type`

Character string specifying the type of data source. Must be one of `'r_dataframe'`, `'sql_server'`, or `'rads'`.

## `connection`

A DBI Connection object.<br>**Required only when `data_source_type = 'sql_server'`**.

## `data_params`

List of data related parameters specific to the data source. Not all parameters are needed for all data sources. Please review the examples for details.

-   

    ### `data_params$check_chi`

    Logical vector of length 1. When `check_chi = TRUE`, function will add any available CHI related variables to `data_params$cols` and, if they are categorical, will assess whether their values align with standards in `rads.data::misc_chi_byvars`.<br>Default is `check_chi = FALSE`.

-   

    ### `data_params$cols`

    Character vector specifying the column names to analyze, e.g., `cols = c('race4', 'birth_weight_grams', 'birthplace_city')`.

-   

    ### `data_params$time_range`

    Character vector of length 2 specifying the start and end of the time range, e.g., `time_range = c(2015, 2024)`.

-   

    ### `data_params$time_var`

    Character string specifying the time interval variable, e.g., `time_var = 'chi_year'`.

-   

    ### `data_params$data`

    Name of a data.frame or data.table that you want to assess with this function, e.g., `data = myDataTable`.<br>**Required only when `data_source_type = 'r_dataframe'`**.

-   

    ### `data_params$function_name`

    Character string specifying the relevant rads::get_data_xxx function, e.g., `function_name = 'get_data_birth'`.<br>**Required only when `data_source_type = 'rads'`**.

-   

    ### `data_params$kingco`

    Logical vector of length 1. Identifies whether you want limit the data to King County.<br>**Required only when `data_source_type = 'rads'`**.<br>Default is `kingco = TRUE`.

-   

    ### `data_params$version`

    Character string specifying either `'final'` or `'stage'`.<br>**Required only when `data_source_type = 'rads'`**.<br>Default is `version = 'stage'`.

-   

    ### `data_params$schema_table`

    The name of the schema and table to be accessed within the SQL Server connection. Must be in the form myschema.mytable, with a period as a separator, e.g., `schema_table = 'birth.stage_analytic'`.<br>**Required only when `data_source_type = 'sql_server'`**.

## `output_directory`

Character string specifying the directory where output files will be saved. If `NULL`, the current working directory is used.<br>Default is `output_directory = NULL`.

## `digits_mean`

Integer specifying the number of decimal places for rounding the reported mean, median, min, and max.<br>Default is `digits_mean = 3`.

## `digits_prop`

Integer specifying the number of decimal places for rounding proportions.<br>Default is `digits_prop = 3`.

## `abs_threshold`

Numeric threshold for flagging *absolute* percentage changes in *proportions.* Permissible range is \[0, 100\].<br>Default is `abs_threshold = 3`.

## `rel_threshold`

Numeric threshold for flagging *relative* percentage changes in *means* and *medians*. Permissible range is \[0, 100\].<br>Default is `rel_threshold = 2`.

## `distinct_threshold`

Integer specifying the minimum number of unique values needed for a numeric or date variable to be analyzed as such. Variables with fewer distinct values will be treated as categoricals.<br>Default is `distinct_threshold = 1`.

# Examples

As stated above, this function can QA data in SQL Server, a local data.table/ data.frame, or from `rads`. Here we provide an example of each method to QA the same data source. Since all three methods provide identical output, we will only explore the SQL Server QA in detail knowing that it is generalizable.

## QA SQL Server data

```{r echo=TRUE, results='show', warning=TRUE, message=TRUE}
myconnection <- rads::validate_hhsaw_key()
qaSQL <- etl_qa_run_pipeline(
  data_source_type = 'sql_server',
  connection = myconnection,
  data_params = list(
    schema_table = 'birth.final_analytic',
    time_var = 'chi_year',
    time_range = c(2013, 2022),
    cols =c('chi_age', 'race4', 'birth_weight_grams', 'birthplace_city', 
            'num_prev_cesarean', 'mother_date_of_birth'), 
    check_chi = TRUE
  ), 
  distinct_threshold = 6,
  output_directory = tempdir()
)
```

Since we set `check_chi = TRUE`, the function pulled in all available CHI related variables and compared them to known standards. In this case, it identified two deviations between the birth data and the CHI standards. However, these are known issues that are related to conception of the CHI variables rather than a data processing issue, so there is a `note` letting the user know not to worry about the discrepancy. I've hidden this message for the examples that follow to simplify this vignette.

The final statement asks the user to check their `output_directory`, which is `tempdir()`. Let's see what is saved there:

```{r echo=TRUE, results='hide', warning=FALSE, message=FALSE}
list.files(tempdir())
```

```{r echo=FALSE, results='show', warning=FALSE, message=FALSE}
list.files(tempdir(),  pattern = '.pdf|.xlsx')
```

-   **`r list.files(tempdir(), pattern = 'qa_missing')`** contains graphs like the one showin in Figure 1.
-   **`r list.files(tempdir(), pattern = 'qa_value')`** contains the graphs like those in Figures 2a, 2b, and 2c.
-   **`r list.files(tempdir(), pattern = '.xlsx')`** contains three worksheeets, one for each of the three tables given in the Tables section above.

We also saved the output as the object `qaSQL`. Let's confirm that what was written about the returned object in the Sneak peek section above was correct:

```{r echo=TRUE, results='show', warning=TRUE, message=TRUE}
# confirm it is a list
inherits(qaSQL, 'list')

# get the name of the object in the returned list
names(qaSQL)

# get the names of the returned tables (which correspond to those in the Excel file)
names(qaSQL$final)

```

## QA data.table / data.frame data in memory

```{r echo=TRUE, results='hide', warning=FALSE, message=FALSE}
birth_data <- rads::get_data_birth(year = c(2013:2022), 
                             kingco = F, 
                             version = 'final')

qaDF <- etl_qa_run_pipeline(
  data_source_type = 'r_dataframe',
  data_params = list(
    data = birth_data,
    time_var = 'chi_year',
    time_range = c(2013, 2022),
    cols = c('chi_age', 'race4', 'birth_weight_grams', 'birthplace_city', 
             'num_prev_cesarean', 'mother_date_of_birth'), 
    check_chi = TRUE
  ), 
  distinct_threshold = 6,
  output_directory = tempdir()
)
```

## QA `rads` data

```{r echo=TRUE, results='hide', warning=FALSE, message=FALSE}
qaRADS <- etl_qa_run_pipeline(
  data_source_type = 'rads',
  data_params = list(
    function_name = 'get_data_birth',
    time_var = 'chi_year',
    time_range = c(2013, 2022),
    cols = c('chi_age', 'race4', 'birth_weight_grams', 'birthplace_city',
             'num_prev_cesarean', 'mother_date_of_birth'),
    version = 'final',
    kingco = FALSE,
    check_chi = TRUE
  ),
  distinct_threshold = 6,
  output_directory = tempdir()
)
```

## Confirm that the results from each method are identical

```{r echo=TRUE, results='show', warning=TRUE, message=TRUE}
isTRUE(all.equal(qaDF$final, qaSQL$final))
isTRUE(all.equal(qaDF$final, qaRADS$final))
```

# Conclusion

Remember to consult the function documentation for more detailed information on usage and parameters. Happy coding!

-- *`r paste0("Updated by ", Sys.getenv("USERNAME"), ", ", Sys.Date())`*
